{
    "version": "https://jsonfeed.org/version/1",
    "title": "SnowRoll Blog • All posts by \"heartbeat, java\" tag",
    "description": "分享经验，记录生活",
    "home_page_url": "https://snowroll.github.io",
    "items": [
        {
            "id": "https://snowroll.github.io/java-heartbeat/",
            "url": "https://snowroll.github.io/java-heartbeat/",
            "title": "Spring Boot中心跳机制的实现",
            "date_published": "2020-09-28T12:09:11.000Z",
            "content_html": "<h3 id=\"内容摘要\"><a class=\"markdownIt-Anchor\" href=\"#内容摘要\">#</a> 内容摘要</h3>\n<ul>\n<li>基于 netty 的心跳机制实现</li>\n<li>基于定时器的心跳机制 demo 实现</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"1-基于netty心跳机制的实现\"><a class=\"markdownIt-Anchor\" href=\"#1-基于netty心跳机制的实现\">#</a> 1. 基于 netty 心跳机制的实现</h3>\n<p>这部分的主要工作是参考 crossoverjie 的博客，博客地址为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcm9zc292ZXJqaWUudG9wLzIwMTgvMDUvMjQvbmV0dHkvTmV0dHkoMSlUQ1AtSGVhcnRiZWF0Lw==\">https://crossoverjie.top/2018/05/24/netty/Netty(1)TCP-Heartbeat/</span></p>\n<p>有兴趣的同学可以移步他的博客进行阅读，我在这里只总结一些我在复现过程中遇到的一些问题及解决方案</p>\n<ul>\n<li>\n<p>在 <code>EchoClienthandle</code>  函数中的 <code>SpringBeanFactory</code>  找不到相关包，下面的语句执行出错</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一行语句出错</span></span><br><span class=\"line\">CustomProtocol heartBeat = SpringBeanFactory.getBean(<span class=\"string\">&quot;heartBeat&quot;</span>, CustomProtocol.class);</span><br><span class=\"line\">ctx.writeAndFlush(heartBeat).addListener(ChannelFutureListener.CLOSE_ON_FAILURE) ;</span><br></pre></td></tr></table></figure>\n<p>解决：</p>\n<p>查找关于 <code>ChannelHandlerContext.writeAndFlush()</code>  定义，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ChannelFuture <span class=\"title\">writeAndFlush</span><span class=\"params\">(Object msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.writeAndFlush(msg, <span class=\"keyword\">this</span>.newPromise());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>知 <code>heartBeat</code>  应为一个对象，所以考虑直接 <code>new</code> ，修改如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CustomProtocol customProtocol = <span class=\"keyword\">new</span> CustomProtocol(<span class=\"number\">1234L</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">ctx.writeAndFlush(customProtocol);</span><br></pre></td></tr></table></figure>\n<p>测试可以使用，具体内容可以自行修改</p>\n</li>\n<li>\n<p>关于编解码的使用</p>\n<p>crossoverjie 的博客提供自定义的编解码器，这个可以根据个人需求进行修改</p>\n<p>无论是客户端的 <code>EchoClientHandle</code>  还是服务器端的 <code>HeartBeatSimpleHandle</code>  都继承自 <code>SimpleChannelInboundHandler&lt;I&gt;</code>  抽象类，可以对不同的数据类型做处理，官方文档 https://netty.io/4.0/api/io/netty/channel/SimpleChannelInboundHandler.html</p>\n<p>对比博客中的定义及对应的编解码方法</p>\n<ul>\n<li>服务器端</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeartBeatSimpleHandle</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">CustomProtocol</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...  略去不重要的内容</span></span><br><span class=\"line\">    <span class=\"comment\">// 服务器端使用ByteBuf进行内容发送</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ByteBuf HEART_BEAT =  Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class=\"keyword\">new</span> CustomProtocol(<span class=\"number\">123456L</span>,<span class=\"string\">&quot;pong&quot;</span>).toString(),CharsetUtil.UTF_8));  </span><br><span class=\"line\">    </span><br><span class=\"line\">  \t<span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里向客户端发送ByteBuf类型的数据，所以客户端必须解析ByteBuf</span></span><br><span class=\"line\">       \tctx.writeAndFlush(HEART_BEAT).addListener(ChannelFutureListener.CLOSE_ON_FAILURE) ;</span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"keyword\">super</span>.userEventTriggered(ctx, evt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, CustomProtocol customProtocol)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 定义了处理CustomProtocol，复现channelRead0</span></span><br><span class=\"line\">        LOGGER.info(<span class=\"string\">&quot;收到customProtocol=&#123;&#125;&quot;</span>, customProtocol);</span><br><span class=\"line\">        <span class=\"comment\">// ... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这段代码应该是在客户端，因为客户端收到的是ByteBuf的内容，所以需要解码为CustomProtocol</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeartbeatDecoder</span> <span class=\"keyword\">extends</span> <span class=\"title\">ByteToMessageDecoder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理不再赘述客户端的内容</p>\n</li>\n<li>\n<p>netty 心跳机制的问题</p>\n<p>netty 底层相当于是基于 socket 连接实现的，所以需要服务器和客户端进行长连接，耦合严重。倘若，甲方不想心跳机制两端的机器保持 socket 的连接，只是简单的定时传送数据该如何实现？这就要用到我接下来提到的方法</p>\n</li>\n</ul>\n<h3 id=\"2-基于定时器的心跳机制demo实现\"><a class=\"markdownIt-Anchor\" href=\"#2-基于定时器的心跳机制demo实现\">#</a> 2.  基于定时器的心跳机制 demo 实现</h3>\n<ul>\n<li>\n<p>代码逻辑</p>\n<p>A 定时请求数据  ==&gt; 发送请求给 B 的接口 ==&gt; B 的接口接收信息，返回对应的信息 ==&gt; A 处理返回的信息</p>\n<p>这个过程不需要 A、B 两者用 socket 连接，实现了解耦</p>\n</li>\n<li>\n<p>定时</p>\n<p>参考博客： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5NjM5NDgvYXJ0aWNsZS9kZXRhaWxzLzUyOTQ2MjY4\">https://blog.csdn.net/u010963948/article/details/52946268</span></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeartBeat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * description: 定时器的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Runnable runnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;hello world!&quot;</span>);  <span class=\"comment\">// 自定义你需要的操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * description: 定时发送心跳， scheduleAtFixedRate param1： 回调函数 param1： 首次执行滞后时间 param1： 间隔时间 param1： 单位时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span>  <span class=\"comment\">// 依赖注入完成之后，方法就要被执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();</span><br><span class=\"line\">        service.scheduleAtFixedRate(runnable, <span class=\"number\">1</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>PostConstruct</code>  这个注释非常重要，注释对应的方法会在程序的依赖加载完成之后执行，这样就可以不用直接写在 <code>main</code>  函数中</p>\n<p>回调函数中的可能需要对 JSON 数据进行分析，可以直接使用 Gson 处理，参考博客 https://blog.csdn.net/xingfei_work/article/details/76572550</p>\n</li>\n</ul>\n<center>侠客行\n</center>\n<center>唐·李白\n<center>赵客缦胡缨，吴钩霜雪明。\n银鞍照白马，飒沓如流星。\n<center>十步杀一人，千里不留行。\n事了拂衣去，深藏身与名。\n<center>闲过信陵饮，脱剑膝前横。将炙啖朱亥，持觞劝侯嬴。\n<center>三杯吐然诺，五岳倒为轻。\n眼花耳热后，意气素霓生。\n<center>救赵挥金槌，邯郸先震惊。\n千秋二壮士，烜赫大梁城。\n<center>纵死侠骨香，不惭世上英。\n谁能书阁下，白首太玄经。\n",
            "tags": [
                "heartbeat, java"
            ]
        }
    ]
}